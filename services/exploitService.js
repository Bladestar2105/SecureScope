const { getDatabase } = require('../config/database');
const logger = require('./logger');

class ExploitService {

    /**
     * Semantic version comparison helper.
     * Returns -1 if a < b, 0 if a == b, 1 if a > b.
     * Handles versions like "2.4.51", "8.0", "7.2p1" etc.
     */
    static compareVersions(a, b) {
        if (!a || !b) return 0;
        // Replace non-numeric sequences with a dot to treat them as version separators
        // This handles "8.2p1" as "8.2.1" and "2.4.51-ubuntu" as "2.4.51"
        const clean = (v) => v.replace(/[^0-9.]+/g, '.').replace(/^\.+|\.+$/g, '');
        const partsA = clean(a).split('.').map(Number);
        const partsB = clean(b).split('.').map(Number);
        const len = Math.max(partsA.length, partsB.length);
        for (let i = 0; i < len; i++) {
            const numA = partsA[i] || 0;
            const numB = partsB[i] || 0;
            if (numA < numB) return -1;
            if (numA > numB) return 1;
        }
        return 0;
    }

    /**
     * Check if a detected version falls within the exploit's vulnerable range.
     * Returns true if the version is potentially vulnerable.
     */
    static isVersionVulnerable(detectedVersion, versionMin, versionMax) {
        if (!detectedVersion) return false;
        // If no version constraints on the exploit, it's a generic exploit
        if (!versionMin && !versionMax) return false;

        // Exact match shortcut
        if (versionMin && detectedVersion === versionMin) return true;
        if (versionMax && detectedVersion === versionMax) return true;

        // Substring match (e.g. detected "2.4.51" contains min "2.4")
        if (versionMin && (detectedVersion.includes(versionMin) || versionMin.includes(detectedVersion))) return true;

        // Range check
        if (versionMin && versionMax) {
            return ExploitService.compareVersions(detectedVersion, versionMin) >= 0 &&
                   ExploitService.compareVersions(detectedVersion, versionMax) <= 0;
        }
        if (versionMin && !versionMax) {
            // Only min specified: vulnerable if detected >= min (assume all versions from min onwards)
            return ExploitService.compareVersions(detectedVersion, versionMin) >= 0;
        }
        if (!versionMin && versionMax) {
            // Only max specified: vulnerable if detected <= max
            return ExploitService.compareVersions(detectedVersion, versionMax) <= 0;
        }
        return false;
    }

    // Get all exploits with filters
    static getAll(filters = {}) {
        const db = getDatabase();
        let query = 'SELECT * FROM exploits WHERE 1=1';
        const params = [];

        if (filters.severity) {
            query += ' AND LOWER(severity) = LOWER(?)';
            params.push(filters.severity);
        }
        if (filters.service) {
            query += ' AND LOWER(service_name) LIKE LOWER(?)';
            params.push(`%${filters.service}%`);
        }
        if (filters.platform) {
            query += ' AND LOWER(platform) LIKE LOWER(?)';
            params.push(`%${filters.platform}%`);
        }
        if (filters.port) {
            query += ' AND port = ?';
            params.push(filters.port);
        }
        if (filters.type) {
            query += ' AND exploit_type = ?';
            params.push(filters.type);
        }
        if (filters.source) {
            query += ' AND source = ?';
            params.push(filters.source);
        }
        if (filters.search) {
            query += ' AND (title LIKE ? OR description LIKE ? OR cve_id LIKE ? OR exploit_db_id LIKE ?)';
            const term = `%${filters.search}%`;
            params.push(term, term, term, term);
        }

        query += ' ORDER BY cvss_score DESC, created_at DESC';

        const page = filters.page || 1;
        const limit = filters.limit || 50;
        const offset = (page - 1) * limit;

        const countQuery = query.replace('SELECT *', 'SELECT COUNT(*) as count');
        const total = db.prepare(countQuery).get(...params);

        query += ' LIMIT ? OFFSET ?';
        params.push(limit, offset);

        const results = db.prepare(query).all(...params);

        return {
            exploits: results,
            pagination: {
                page, limit,
                total: total.count,
                totalPages: Math.ceil(total.count / limit)
            }
        };
    }

    // Get exploit by ID
    static getById(id) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE id = ?').get(id);
    }

    // Get exploits by CVE
    static getByCVE(cveId) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE cve_id = ? ORDER BY cvss_score DESC').all(cveId);
    }

    // Get exploits for a specific service
    static getByService(serviceName) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE LOWER(service_name) = LOWER(?) ORDER BY cvss_score DESC').all(serviceName);
    }

    // Get exploits for a specific port
    static getByPort(port) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE port = ? ORDER BY cvss_score DESC').all(port);
    }

    // Helper to get service aliases
    static getAliases(serviceName) {
        if (!serviceName) return [];
        const lower = serviceName.toLowerCase();
        const aliases = new Set([lower]);

        const map = {
            'smb': ['microsoft-ds', 'netbios-ssn', 'netapi', 'microsoft server service'],
            'microsoft-ds': ['smb', 'netbios-ssn', 'netapi', 'microsoft server service'],
            'netbios-ssn': ['smb', 'microsoft-ds'],
            'http': ['www', 'http-alt', 'apache', 'nginx', 'iis'],
            'www': ['http', 'https'],
            'https': ['www', 'http', 'ssl/http'],
            'rpc': ['msrpc', 'dcerpc'],
            'msrpc': ['rpc', 'dcerpc'],
            'rdp': ['ms-wbt-server', 'terminal services'],
            'ms-wbt-server': ['rdp', 'terminal services'],
            'ssh': ['openssh'],
            'openssh': ['ssh']
        };

        if (map[lower]) {
            map[lower].forEach(a => aliases.add(a));
        }

        return Array.from(aliases);
    }

    /**
     * OPTIMIZED: Match scan results against exploit database.
     * Only matches exploits where the detected service version falls within the exploit's
     * vulnerable version range. Generic port-only matches are excluded unless no version info exists.
     */
    static matchScanResults(scanId) {
        const db = getDatabase();

        // Get scan results with fingerprint data AND nmap service detection
        // Include os_name from scan_results for platform matching (critical for legacy OS like Windows XP)
        const scanResults = db.prepare(`
            SELECT sr.*, sf.detected_service, sf.detected_version, sf.detected_os, sf.cpe,
                   COALESCE(sf.detected_os, sr.os_name) as effective_os
            FROM scan_results sr
            LEFT JOIN scan_fingerprints sf ON sr.id = sf.scan_result_id AND sr.scan_id = sf.scan_id
            WHERE sr.scan_id = ? AND sr.state = 'open'
        `).all(scanId);

        if (scanResults.length === 0) return [];

        const matches = [];
        const insertStmt = db.prepare(`
            INSERT OR IGNORE INTO scan_exploits (scan_id, scan_result_id, exploit_id, match_confidence, match_reason)
            VALUES (?, ?, ?, ?, ?)
        `);

        // Optimization: Prepare statements once outside the loop
        const portMatchStmt = db.prepare('SELECT * FROM exploits WHERE port = ?');
        const fuzzyMatchStmt = db.prepare(
            'SELECT * FROM exploits WHERE LOWER(service_name) LIKE LOWER(?) AND (port IS NULL OR port = ?)'
        );

        // Cache for IN clause statements with different number of placeholders
        const inMatchStmtCache = new Map();
        const getInMatchStmt = (num) => {
            if (!inMatchStmtCache.has(num)) {
                const placeholders = Array(num).fill('?').join(',');
                inMatchStmtCache.set(num, db.prepare(
                    `SELECT * FROM exploits WHERE LOWER(service_name) IN (${placeholders}) AND (port IS NULL OR port = ?)`
                ));
            }
            return inMatchStmtCache.get(num);
        };

        const matchAll = db.transaction(() => {
            for (const result of scanResults) {
                // Determine the best available version info
                const detectedService = result.detected_service || result.service || null;
                const detectedVersion = result.detected_version || result.service_version || null;
                const detectedProduct = result.service_product || null;

                let exploits = [];

                // 1. Match by port
                const portExploits = portMatchStmt.all(result.port);
                exploits.push(...portExploits);

                // 2. Match by detected service name (from fingerprinting)
                if (detectedService) {
                    const aliases = ExploitService.getAliases(detectedService);
                    const serviceExploits = getInMatchStmt(aliases.length).all(...aliases, result.port);

                    for (const se of serviceExploits) {
                        if (!exploits.find(e => e.id === se.id)) {
                            exploits.push(se);
                        }
                    }
                }

                // 3. Match by basic service name from scan_results
                if (result.service) {
                    // Try aliases first
                    const aliases = ExploitService.getAliases(result.service);
                    const aliasExploits = getInMatchStmt(aliases.length).all(...aliases, result.port);
                    for (const ae of aliasExploits) {
                        if (!exploits.find(e => e.id === ae.id)) exploits.push(ae);
                    }

                    // Also keep the original LIKE query for fuzzy matching
                    const basicServiceExploits = fuzzyMatchStmt.all(`%${result.service}%`, result.port);
                    for (const bse of basicServiceExploits) {
                        if (!exploits.find(e => e.id === bse.id)) {
                            exploits.push(bse);
                        }
                    }
                }

                // 4. Match by product name (e.g. "Apache httpd" -> "apache")
                if (detectedProduct) {
                    const productExploits = fuzzyMatchStmt.all(`%${detectedProduct}%`, result.port);
                    for (const pe of productExploits) {
                        if (!exploits.find(e => e.id === pe.id)) {
                            exploits.push(pe);
                        }
                    }
                }

                // Deduplicate and calculate confidence WITH version filtering
                const seen = new Set();
                // Detect OS from scan result for platform matching
                const detectedOs = (result.effective_os || result.os_name || '').toLowerCase();

                for (const exploit of exploits) {
                    if (seen.has(exploit.id)) continue;
                    seen.add(exploit.id);

                    let confidence = 0;
                    let reasons = [];
                    let versionMatched = false;
                    let serviceMatched = false;

                    // --- Service name match ---
                    if (detectedService && exploit.service_name) {
                        const svcLower = detectedService.toLowerCase();
                        const exploitSvcLower = exploit.service_name.toLowerCase();
                        const aliases = ExploitService.getAliases(detectedService);

                        if (svcLower === exploitSvcLower || svcLower.includes(exploitSvcLower) || exploitSvcLower.includes(svcLower) || aliases.includes(exploitSvcLower)) {
                            confidence += 25;
                            reasons.push('Service-Match');
                            serviceMatched = true;
                        }
                    }

                    // Also check product name
                    if (!serviceMatched && detectedProduct && exploit.service_name) {
                        const prodLower = detectedProduct.toLowerCase();
                        const exploitSvcLower = exploit.service_name.toLowerCase();
                        if (prodLower.includes(exploitSvcLower) || exploitSvcLower.includes(prodLower)) {
                            confidence += 20;
                            reasons.push('Produkt-Match');
                            serviceMatched = true;
                        }
                    }

                    // --- Port match ---
                    if (exploit.port === result.port) {
                        confidence += 15;
                        reasons.push('Port-Match');
                    }

                    // --- OS / Platform match (critical for legacy systems like Windows XP) ---
                    let platformMatched = false;
                    if (detectedOs && exploit.platform) {
                        const platLower = exploit.platform.toLowerCase();
                        const detectedOsLower = detectedOs.toLowerCase();
                        
                        // IMPROVED: More robust platform matching for legacy systems
                        if (
                            (detectedOsLower.includes('windows') && platLower.includes('windows')) ||
                            (detectedOsLower.includes('linux') && platLower.includes('linux')) ||
                            (detectedOsLower.includes('unix') && (platLower.includes('linux') || platLower.includes('unix'))) ||
                            platLower === 'multi' ||
                            // Special handling for Windows XP/2000/2003 legacy systems
                            (detectedOsLower.includes('xp') && platLower.includes('windows')) ||
                            (detectedOsLower.includes('2000') && platLower.includes('windows')) ||
                            (detectedOsLower.includes('2003') && platLower.includes('windows'))
                        ) {
                            confidence += 15; // Increased from 10
                            reasons.push('Plattform-Match');
                            platformMatched = true;
                        }
                    }

                    // --- VERSION MATCHING ---
                    if (detectedVersion && (exploit.service_version_min || exploit.service_version_max)) {
                        if (ExploitService.isVersionVulnerable(detectedVersion, exploit.service_version_min, exploit.service_version_max)) {
                            confidence += 45;
                            reasons.push('Version-Match');
                            versionMatched = true;
                        } else {
                            // Version is KNOWN but does NOT match the exploit's range
                            // This exploit is NOT applicable -> skip it entirely
                            continue;
                        }
                    } else if (detectedVersion && !exploit.service_version_min && !exploit.service_version_max) {
                        // Exploit has no version constraints (generic exploit)
                        // Include if service or platform matches
                        if (serviceMatched || platformMatched) {
                            confidence += 10;
                            reasons.push('Generischer Exploit');
                        } else if (exploit.port === result.port) {
                            // Port-only match for generic exploit - include with lower confidence
                            confidence += 5;
                            reasons.push('Generischer Port-Exploit');
                        } else {
                            continue;
                        }
                    } else if (!detectedVersion && (exploit.service_version_min || exploit.service_version_max)) {
                        // No version info detected but exploit requires specific version
                        // This is common for legacy systems (e.g. Windows XP without SP)
                        // IMPROVED: Include with higher confidence for legacy systems
                        if (serviceMatched && exploit.port === result.port) {
                            confidence += 25; // Increased from 20
                            reasons.push('Version unbekannt (Service+Port)');
                        } else if (serviceMatched && platformMatched) {
                            confidence += 20; // Increased from 15
                            reasons.push('Version unbekannt (Service+Plattform)');
                        } else if (serviceMatched) {
                            confidence += 15; // Increased from 10
                            reasons.push('Version unbekannt (Service)');
                        } else if (exploit.port === result.port && platformMatched) {
                            confidence += 15; // Increased from 10
                            reasons.push('Version unbekannt (Port+Plattform)');
                        } else {
                            continue;
                        }
                    } else {
                        // Neither has version info
                        if (serviceMatched) {
                            confidence += 10;
                            reasons.push('Basis-Match');
                        } else if (exploit.port === result.port && platformMatched) {
                            confidence += 5;
                            reasons.push('Port+Plattform-Match');
                        } else if (!serviceMatched) {
                            continue;
                        }
                    }

                    // Verified exploit bonus
                    if (exploit.verified) {
                        confidence += 10;
                        reasons.push('Verifiziert');
                    }

                    confidence = Math.min(confidence, 100);

                    // Only include matches with minimum confidence
                    // IMPROVED: Lower threshold for legacy systems with unknown versions
                    if (confidence < 15) continue;

                    insertStmt.run(scanId, result.id, exploit.id, confidence, reasons.join(', '));

                    matches.push({
                        scanResultId: result.id,
                        ip: result.ip_address,
                        port: result.port,
                        service: detectedService || result.service,
                        version: detectedVersion,
                        exploit: {
                            id: exploit.id,
                            exploitDbId: exploit.exploit_db_id,
                            cveId: exploit.cve_id,
                            title: exploit.title,
                            severity: exploit.severity,
                            cvssScore: exploit.cvss_score,
                            platform: exploit.platform,
                            reliability: exploit.reliability,
                            sourceUrl: exploit.source_url,
                            versionMin: exploit.service_version_min,
                            versionMax: exploit.service_version_max
                        },
                        confidence: confidence,
                        matchReason: reasons.join(', '),
                        versionMatched: versionMatched
                    });
                }
            }
        });

        matchAll();
        logger.info(`Exploit matching (optimized): ${matches.length} version-filtered matches for scan ${scanId}`);
        return matches;
    }

    // Get exploit matches for a scan
    static getScanExploits(scanId) {
        const db = getDatabase();
        return db.prepare(`
            SELECT se.*, sr.ip_address, sr.port, sr.protocol, sr.service,
                   sr.service_version, sr.service_product,
                   e.exploit_db_id, e.cve_id, e.title as exploit_title, e.description as exploit_description,
                   e.platform, e.exploit_type, e.severity, e.cvss_score, e.reliability,
                   e.source, e.source_url, e.service_name as exploit_service,
                   e.service_version_min, e.service_version_max
            FROM scan_exploits se
            JOIN scan_results sr ON se.scan_result_id = sr.id
            JOIN exploits e ON se.exploit_id = e.id
            WHERE se.scan_id = ?
            ORDER BY se.match_confidence DESC, e.cvss_score DESC
        `).all(scanId);
    }

    // Get exploit summary for a scan
    static getScanExploitSummary(scanId) {
        const db = getDatabase();
        const summary = db.prepare(`
            SELECT e.severity, COUNT(DISTINCT e.id) as count
            FROM scan_exploits se
            JOIN exploits e ON se.exploit_id = e.id
            WHERE se.scan_id = ?
            GROUP BY e.severity
        `).all(scanId);

        const result = { critical: 0, high: 0, medium: 0, low: 0, total: 0 };
        for (const row of summary) {
            result[row.severity] = row.count;
            result.total += row.count;
        }
        return result;
    }

    /**
     * NEW: Get exploits matched to a specific IP and its detected services.
     * Returns only exploits that are relevant based on version matching.
     */
    static getMatchedExploitsForTarget(scanId, targetIp) {
        const db = getDatabase();
        return db.prepare(`
            SELECT se.*, sr.ip_address, sr.port, sr.protocol, sr.service,
                   sr.service_version, sr.service_product,
                   e.exploit_db_id, e.cve_id, e.title as exploit_title, e.description as exploit_description,
                   e.platform, e.exploit_type, e.severity, e.cvss_score, e.reliability,
                   e.source, e.source_url, e.service_name as exploit_service,
                   e.service_version_min, e.service_version_max, e.exploit_code
            FROM scan_exploits se
            JOIN scan_results sr ON se.scan_result_id = sr.id
            JOIN exploits e ON se.exploit_id = e.id
            WHERE se.scan_id = ? AND sr.ip_address = ?
            ORDER BY se.match_confidence DESC, e.cvss_score DESC
        `).all(scanId, targetIp);
    }

    /**
     * NEW: Get a summary of attackable services for a target IP.
     * Groups exploits by port/service and shows which services have matching exploits.
     */
    static getAttackableSummary(scanId, targetIp) {
        const db = getDatabase();

        // Get all open ports for this target
        const openPorts = db.prepare(`
            SELECT sr.*, sf.detected_service, sf.detected_version, sf.detected_os
            FROM scan_results sr
            LEFT JOIN scan_fingerprints sf ON sr.id = sf.scan_result_id AND sr.scan_id = sf.scan_id
            WHERE sr.scan_id = ? AND sr.ip_address = ? AND sr.state = 'open'
            ORDER BY sr.port ASC
        `).all(scanId, targetIp);

        // Get matched exploits per port
        const exploitsByPort = db.prepare(`
            SELECT sr.port, COUNT(DISTINCT se.exploit_id) as exploit_count,
                   MAX(se.match_confidence) as max_confidence,
                   MAX(e.cvss_score) as max_cvss,
                   GROUP_CONCAT(DISTINCT e.severity) as severities
            FROM scan_exploits se
            JOIN scan_results sr ON se.scan_result_id = sr.id
            JOIN exploits e ON se.exploit_id = e.id
            WHERE se.scan_id = ? AND sr.ip_address = ?
            GROUP BY sr.port
        `).all(scanId, targetIp);

        const exploitMap = {};
        for (const ep of exploitsByPort) {
            exploitMap[ep.port] = ep;
        }

        return openPorts.map(port => {
            const exploitInfo = exploitMap[port.port] || null;
            return {
                port: port.port,
                protocol: port.protocol,
                service: port.detected_service || port.service || 'unknown',
                version: port.detected_version || port.service_version || null,
                product: port.service_product || null,
                os: port.detected_os || null,
                hasExploits: !!exploitInfo,
                exploitCount: exploitInfo ? exploitInfo.exploit_count : 0,
                maxConfidence: exploitInfo ? exploitInfo.max_confidence : 0,
                maxCvss: exploitInfo ? exploitInfo.max_cvss : 0,
                severities: exploitInfo ? exploitInfo.severities : null
            };
        });
    }

    // Get statistics
    static getStats() {
        const db = getDatabase();
        const total = db.prepare('SELECT COUNT(*) as count FROM exploits').get();
        // Normalize severity to lowercase for consistent counting
        const bySeverity = db.prepare('SELECT LOWER(severity) as severity, COUNT(*) as count FROM exploits GROUP BY LOWER(severity)').all();
        const byPlatform = db.prepare('SELECT platform, COUNT(*) as count FROM exploits GROUP BY platform ORDER BY count DESC').all();
        const bySource = db.prepare('SELECT source, COUNT(*) as count FROM exploits GROUP BY source ORDER BY count DESC').all();

        return { total: total.count, bySeverity, byPlatform, bySource };
    }

    // Create a new exploit entry
    static create(data) {
        const db = getDatabase();
        const result = db.prepare(`
            INSERT INTO exploits (exploit_db_id, cve_id, title, description, platform, exploit_type, service_name,
                service_version_min, service_version_max, port, severity, cvss_score, reliability, source, source_url, verified)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).run(
            data.exploitDbId || data.exploit_db_id || null,
            data.cveId || data.cve_id || null,
            data.title,
            data.description || null,
            data.platform || 'Multi',
            data.exploitType || data.exploit_type || 'remote',
            data.serviceName || data.service_name || null,
            data.serviceVersionMin || data.service_version_min || null,
            data.serviceVersionMax || data.service_version_max || null,
            data.port || null,
            data.severity || 'high',
            data.cvssScore || data.cvss_score || null,
            data.reliability || 'unknown',
            data.source || 'manual',
            data.sourceUrl || data.source_url || null,
            data.verified ? 1 : 0
        );
        logger.info(`Exploit created: ${data.title} (ID: ${result.lastInsertRowid})`);
        return result.lastInsertRowid;
    }

    // Delete an exploit entry
    static delete(id) {
        const db = getDatabase();
        db.prepare('DELETE FROM exploits WHERE id = ?').run(id);
        logger.info(`Exploit deleted: ID ${id}`);
    }
}

module.exports = ExploitService;