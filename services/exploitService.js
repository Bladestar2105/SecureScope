const { getDatabase } = require('../config/database');
const logger = require('./logger');

class ExploitService {

    // Get all exploits with filters
    static getAll(filters = {}) {
        const db = getDatabase();
        let query = 'SELECT * FROM exploits WHERE 1=1';
        const params = [];

        if (filters.severity) {
            query += ' AND severity = ?';
            params.push(filters.severity);
        }
        if (filters.service) {
            query += ' AND LOWER(service_name) LIKE LOWER(?)';
            params.push(`%${filters.service}%`);
        }
        if (filters.platform) {
            query += ' AND LOWER(platform) LIKE LOWER(?)';
            params.push(`%${filters.platform}%`);
        }
        if (filters.port) {
            query += ' AND port = ?';
            params.push(filters.port);
        }
        if (filters.type) {
            query += ' AND exploit_type = ?';
            params.push(filters.type);
        }
        if (filters.search) {
            query += ' AND (title LIKE ? OR description LIKE ? OR cve_id LIKE ? OR exploit_db_id LIKE ?)';
            const term = `%${filters.search}%`;
            params.push(term, term, term, term);
        }

        query += ' ORDER BY cvss_score DESC, created_at DESC';

        const page = filters.page || 1;
        const limit = filters.limit || 50;
        const offset = (page - 1) * limit;

        const countQuery = query.replace('SELECT *', 'SELECT COUNT(*) as count');
        const total = db.prepare(countQuery).get(...params);

        query += ' LIMIT ? OFFSET ?';
        params.push(limit, offset);

        const results = db.prepare(query).all(...params);

        return {
            exploits: results,
            pagination: {
                page, limit,
                total: total.count,
                totalPages: Math.ceil(total.count / limit)
            }
        };
    }

    // Get exploit by ID
    static getById(id) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE id = ?').get(id);
    }

    // Get exploits by CVE
    static getByCVE(cveId) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE cve_id = ? ORDER BY cvss_score DESC').all(cveId);
    }

    // Get exploits for a specific service
    static getByService(serviceName) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE LOWER(service_name) = LOWER(?) ORDER BY cvss_score DESC').all(serviceName);
    }

    // Get exploits for a specific port
    static getByPort(port) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM exploits WHERE port = ? ORDER BY cvss_score DESC').all(port);
    }

    // Match scan results against exploit database
    static matchScanResults(scanId) {
        const db = getDatabase();

        // Get scan results with fingerprint data
        const scanResults = db.prepare(`
            SELECT sr.*, sf.detected_service, sf.detected_version, sf.detected_os, sf.cpe
            FROM scan_results sr
            LEFT JOIN scan_fingerprints sf ON sr.id = sf.scan_result_id AND sr.scan_id = sf.scan_id
            WHERE sr.scan_id = ? AND sr.state = 'open'
        `).all(scanId);

        if (scanResults.length === 0) return [];

        const matches = [];
        const insertStmt = db.prepare(`
            INSERT OR IGNORE INTO scan_exploits (scan_id, scan_result_id, exploit_id, match_confidence, match_reason)
            VALUES (?, ?, ?, ?, ?)
        `);

        const matchAll = db.transaction(() => {
            for (const result of scanResults) {
                let exploits = [];

                // Match by port
                const portExploits = db.prepare('SELECT * FROM exploits WHERE port = ?').all(result.port);
                exploits.push(...portExploits);

                // Match by detected service name (from fingerprinting)
                if (result.detected_service) {
                    const serviceExploits = db.prepare(
                        'SELECT * FROM exploits WHERE LOWER(service_name) = LOWER(?) AND (port IS NULL OR port = ?)'
                    ).all(result.detected_service, result.port);

                    // Add unique exploits
                    for (const se of serviceExploits) {
                        if (!exploits.find(e => e.id === se.id)) {
                            exploits.push(se);
                        }
                    }
                }

                // Also match by the basic service name from scan_results
                if (result.service) {
                    const basicServiceExploits = db.prepare(
                        'SELECT * FROM exploits WHERE LOWER(service_name) LIKE LOWER(?) AND (port IS NULL OR port = ?)'
                    ).all(`%${result.service}%`, result.port);

                    for (const bse of basicServiceExploits) {
                        if (!exploits.find(e => e.id === bse.id)) {
                            exploits.push(bse);
                        }
                    }
                }

                // Deduplicate and calculate confidence
                const seen = new Set();
                for (const exploit of exploits) {
                    if (seen.has(exploit.id)) continue;
                    seen.add(exploit.id);

                    let confidence = 40; // Base confidence for port match
                    let reasons = [];

                    // Port match
                    if (exploit.port === result.port) {
                        confidence += 20;
                        reasons.push('Port-Match');
                    }

                    // Service name match
                    if (result.detected_service && exploit.service_name &&
                        result.detected_service.toLowerCase().includes(exploit.service_name.toLowerCase())) {
                        confidence += 25;
                        reasons.push('Service-Match');
                    }

                    // Version range match
                    if (result.detected_version && exploit.service_version_min) {
                        confidence += 15;
                        reasons.push('Version-Bereich');
                    }

                    // Verified exploit bonus
                    if (exploit.verified) {
                        confidence += 10;
                        reasons.push('Verifiziert');
                    }

                    confidence = Math.min(confidence, 100);

                    insertStmt.run(scanId, result.id, exploit.id, confidence, reasons.join(', '));

                    matches.push({
                        scanResultId: result.id,
                        ip: result.ip_address,
                        port: result.port,
                        service: result.detected_service || result.service,
                        exploit: {
                            id: exploit.id,
                            exploitDbId: exploit.exploit_db_id,
                            cveId: exploit.cve_id,
                            title: exploit.title,
                            severity: exploit.severity,
                            cvssScore: exploit.cvss_score,
                            platform: exploit.platform,
                            reliability: exploit.reliability,
                            sourceUrl: exploit.source_url
                        },
                        confidence: confidence,
                        matchReason: reasons.join(', ')
                    });
                }
            }
        });

        matchAll();
        logger.info(`Exploit matching: ${matches.length} matches for scan ${scanId}`);
        return matches;
    }

    // Get exploit matches for a scan
    static getScanExploits(scanId) {
        const db = getDatabase();
        return db.prepare(`
            SELECT se.*, sr.ip_address, sr.port, sr.protocol, sr.service,
                   e.exploit_db_id, e.cve_id, e.title as exploit_title, e.description as exploit_description,
                   e.platform, e.exploit_type, e.severity, e.cvss_score, e.reliability,
                   e.source, e.source_url, e.service_name as exploit_service
            FROM scan_exploits se
            JOIN scan_results sr ON se.scan_result_id = sr.id
            JOIN exploits e ON se.exploit_id = e.id
            WHERE se.scan_id = ?
            ORDER BY e.cvss_score DESC, se.match_confidence DESC
        `).all(scanId);
    }

    // Get exploit summary for a scan
    static getScanExploitSummary(scanId) {
        const db = getDatabase();
        const summary = db.prepare(`
            SELECT e.severity, COUNT(DISTINCT e.id) as count
            FROM scan_exploits se
            JOIN exploits e ON se.exploit_id = e.id
            WHERE se.scan_id = ?
            GROUP BY e.severity
        `).all(scanId);

        const result = { critical: 0, high: 0, medium: 0, low: 0, total: 0 };
        for (const row of summary) {
            result[row.severity] = row.count;
            result.total += row.count;
        }
        return result;
    }

    // Get statistics
    static getStats() {
        const db = getDatabase();
        const total = db.prepare('SELECT COUNT(*) as count FROM exploits').get();
        const bySeverity = db.prepare('SELECT severity, COUNT(*) as count FROM exploits GROUP BY severity').all();
        const byPlatform = db.prepare('SELECT platform, COUNT(*) as count FROM exploits GROUP BY platform ORDER BY count DESC').all();
        const bySource = db.prepare('SELECT source, COUNT(*) as count FROM exploits GROUP BY source ORDER BY count DESC').all();

        return { total: total.count, bySeverity, byPlatform, bySource };
    }

    // Create a new exploit entry
    static create(data) {
        const db = getDatabase();
        const result = db.prepare(`
            INSERT INTO exploits (exploit_db_id, cve_id, title, description, platform, exploit_type, service_name,
                service_version_min, service_version_max, port, severity, cvss_score, reliability, source, source_url, verified)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).run(
            data.exploitDbId || data.exploit_db_id || null,
            data.cveId || data.cve_id || null,
            data.title,
            data.description || null,
            data.platform || 'Multi',
            data.exploitType || data.exploit_type || 'remote',
            data.serviceName || data.service_name || null,
            data.serviceVersionMin || data.service_version_min || null,
            data.serviceVersionMax || data.service_version_max || null,
            data.port || null,
            data.severity || 'high',
            data.cvssScore || data.cvss_score || null,
            data.reliability || 'unknown',
            data.source || 'manual',
            data.sourceUrl || data.source_url || null,
            data.verified ? 1 : 0
        );
        logger.info(`Exploit created: ${data.title} (ID: ${result.lastInsertRowid})`);
        return result.lastInsertRowid;
    }

    // Delete an exploit entry
    static delete(id) {
        const db = getDatabase();
        db.prepare('DELETE FROM exploits WHERE id = ?').run(id);
        logger.info(`Exploit deleted: ID ${id}`);
    }
}

module.exports = ExploitService;