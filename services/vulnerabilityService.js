const { getDatabase } = require('../config/database');
const logger = require('./logger');

class VulnerabilityService {
    // Get vulnerabilities for a specific port
    static getByPort(port) {
        const db = getDatabase();
        return db.prepare(
            'SELECT * FROM vulnerabilities WHERE port = ? ORDER BY cvss_score DESC'
        ).all(port);
    }

    // Get vulnerabilities for a specific service
    static getByService(service) {
        const db = getDatabase();
        return db.prepare(
            'SELECT * FROM vulnerabilities WHERE LOWER(service) = LOWER(?) ORDER BY cvss_score DESC'
        ).all(service);
    }

    // Get vulnerability by ID
    static getById(id) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM vulnerabilities WHERE id = ?').get(id);
    }

    // Get vulnerability by CVE ID
    static getByCVE(cveId) {
        const db = getDatabase();
        return db.prepare('SELECT * FROM vulnerabilities WHERE cve_id = ?').get(cveId);
    }

    // Get all vulnerabilities with optional filters
    static getAll(filters = {}) {
        const db = getDatabase();
        let query = 'SELECT * FROM vulnerabilities WHERE 1=1';
        const params = [];

        if (filters.severity) {
            query += ' AND severity = ?';
            params.push(filters.severity);
        }
        if (filters.service) {
            query += ' AND LOWER(service) = LOWER(?)';
            params.push(filters.service);
        }
        if (filters.port) {
            query += ' AND port = ?';
            params.push(filters.port);
        }
        if (filters.search) {
            query += ' AND (title LIKE ? OR description LIKE ? OR cve_id LIKE ?)';
            const term = `%${filters.search}%`;
            params.push(term, term, term);
        }

        query += ' ORDER BY cvss_score DESC';

        const page = filters.page || 1;
        const limit = filters.limit || 50;
        const offset = (page - 1) * limit;

        const countQuery = query.replace('SELECT *', 'SELECT COUNT(*) as count');
        const total = db.prepare(countQuery).get(...params);

        query += ' LIMIT ? OFFSET ?';
        params.push(limit, offset);

        const results = db.prepare(query).all(...params);

        return {
            vulnerabilities: results,
            pagination: {
                page,
                limit,
                total: total.count,
                totalPages: Math.ceil(total.count / limit)
            }
        };
    }

    // Match scan results against vulnerability database
    static matchScanResults(scanId) {
        const db = getDatabase();

        // Get all scan results for this scan
        const scanResults = db.prepare(
            'SELECT * FROM scan_results WHERE scan_id = ?'
        ).all(scanId);

        if (scanResults.length === 0) return [];

        const matches = [];
        const insertStmt = db.prepare(`
            INSERT OR IGNORE INTO scan_vulnerabilities
            (scan_id, scan_result_id, cve_id, title, severity, cvss_score, matched_service, matched_version, match_confidence)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);

        // Prepare select statement outside loop for better performance
        const selectVulnsStmt = db.prepare('SELECT * FROM vulnerabilities WHERE port = ?');

        const matchAll = db.transaction(() => {
            for (const result of scanResults) {
                // Find vulnerabilities matching this port
                const vulns = selectVulnsStmt.all(result.port);

                for (const vuln of vulns) {
                    try {
                        insertStmt.run(
                            scanId,
                            result.id,
                            vuln.cve_id,
                            vuln.title,
                            vuln.severity,
                            vuln.cvss_score,
                            result.service_product || result.service,
                            result.service_version,
                            50 // Low confidence for port-only match
                        );

                        matches.push({
                            scanResultId: result.id,
                            ip: result.ip_address,
                            port: result.port,
                            service: result.service,
                            vulnerability: {
                                id: vuln.id,
                                cveId: vuln.cve_id,
                                title: vuln.title,
                                severity: vuln.severity,
                                cvssScore: vuln.cvss_score,
                                description: vuln.description,
                                remediation: vuln.remediation
                            }
                        });
                    } catch (e) {
                        logger.error(`Error inserting vulnerability for scan ${scanId}, CVE ${vuln.cve_id}:`, e);
                    }
                }
            }
        });

        matchAll();

        logger.info(`Matched ${matches.length} vulnerabilities for scan ${scanId}`);
        return matches;
    }

    // Get vulnerabilities found in a specific scan
    static getScanVulnerabilities(scanId) {
        const db = getDatabase();
        return db.prepare(`
            SELECT 
                sv.id as match_id,
                sr.ip_address, sr.port, sr.protocol, sr.service, sr.state,
                sv.cve_id as vuln_id, sv.cve_id, sv.severity, sv.title, ce.description,
                NULL as remediation, sv.cvss_score
            FROM scan_vulnerabilities sv
            JOIN scan_results sr ON sv.scan_result_id = sr.id
            LEFT JOIN cve_entries ce ON sv.cve_id = ce.cve_id
            WHERE sv.scan_id = ?
            ORDER BY sv.cvss_score DESC
        `).all(scanId);
    }

    // Get vulnerability summary for a scan
    static getScanVulnerabilitySummary(scanId) {
        const db = getDatabase();
        const summary = db.prepare(`
            SELECT 
                severity,
                COUNT(*) as count
            FROM scan_vulnerabilities
            WHERE scan_id = ?
            GROUP BY severity
        `).all(scanId);

        const result = { critical: 0, high: 0, medium: 0, low: 0, total: 0 };
        for (const row of summary) {
            result[row.severity] = row.count;
            result.total += row.count;
        }
        return result;
    }

    // Add a custom vulnerability entry
    static create(data) {
        const db = getDatabase();
        const result = db.prepare(`
            INSERT INTO vulnerabilities (cve_id, port, protocol, service, severity, title, description, remediation, cvss_score, references_url)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).run(
            data.cveId || null,
            data.port,
            data.protocol || 'tcp',
            data.service,
            data.severity,
            data.title,
            data.description || null,
            data.remediation || null,
            data.cvssScore || null,
            data.referencesUrl || null
        );

        logger.info(`Vulnerability created: ${data.title} (ID: ${result.lastInsertRowid})`);
        return result.lastInsertRowid;
    }

    // Update a vulnerability entry
    static update(id, data) {
        const db = getDatabase();
        db.prepare(`
            UPDATE vulnerabilities SET
                cve_id = COALESCE(?, cve_id),
                port = COALESCE(?, port),
                protocol = COALESCE(?, protocol),
                service = COALESCE(?, service),
                severity = COALESCE(?, severity),
                title = COALESCE(?, title),
                description = COALESCE(?, description),
                remediation = COALESCE(?, remediation),
                cvss_score = COALESCE(?, cvss_score),
                references_url = COALESCE(?, references_url)
            WHERE id = ?
        `).run(
            data.cveId, data.port, data.protocol, data.service,
            data.severity, data.title, data.description,
            data.remediation, data.cvssScore, data.referencesUrl, id
        );
        logger.info(`Vulnerability updated: ID ${id}`);
    }

    // Delete a vulnerability entry
    static delete(id) {
        const db = getDatabase();
        db.prepare('DELETE FROM vulnerabilities WHERE id = ?').run(id);
        logger.info(`Vulnerability deleted: ID ${id}`);
    }
}

module.exports = VulnerabilityService;