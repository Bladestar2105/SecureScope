const { getDatabase } = require('../config/database');
const logger = require('./logger');
const fs = require('fs');
const path = require('path');
const { execSync, exec } = require('child_process');

const DATA_DIR = path.join(__dirname, '..', 'data');
const EXPLOITDB_DIR = path.join(DATA_DIR, 'exploitdb');
const EXPLOITDB_REPO = 'https://gitlab.com/exploit-database/exploitdb.git';

class ExploitDbSyncService {

    static progressCallbacks = new Map();

    static ensureDirs() {
        if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
    }

    static onProgress(id, cb) { this.progressCallbacks.set(id, cb); }
    static offProgress(id) { this.progressCallbacks.delete(id); }
    static emitProgress(phase, pct, msg) {
        for (const cb of this.progressCallbacks.values()) {
            try { cb({ phase, percent: pct, message: msg }); } catch (e) {}
        }
    }

    /**
     * Check if the exploitdb repo already exists locally
     */
    static isRepoCloned() {
        return fs.existsSync(path.join(EXPLOITDB_DIR, '.git'));
    }

    /**
     * Full sync: clone or pull the exploitdb repo, then parse files_exploits.csv
     */
    static async syncAll(userId) {
        this.ensureDirs();
        const db = getDatabase();
        const countBefore = db.prepare('SELECT COUNT(*) as c FROM exploits').get().c;

        const logEntry = db.prepare(`
            INSERT INTO db_update_log (database_type, source, entries_before, status, triggered_by)
            VALUES ('exploits', 'exploit-database/exploitdb (GitLab)', ?, 'running', ?)
        `).run(countBefore, userId);
        const logId = logEntry.lastInsertRowid;

        try {
            // Step 1: Clone or pull the repo
            if (this.isRepoCloned()) {
                this.emitProgress('download', 5, 'Aktualisiere ExploitDB Repository (git pull)...');
                try {
                    execSync(`cd "${EXPLOITDB_DIR}" && git pull --ff-only 2>&1`, {
                        maxBuffer: 50 * 1024 * 1024,
                        timeout: 300000
                    });
                } catch (e) {
                    // If pull fails, try reset
                    this.emitProgress('download', 10, 'Git pull fehlgeschlagen, versuche Reset...');
                    execSync(`cd "${EXPLOITDB_DIR}" && git fetch origin && git reset --hard origin/main 2>&1`, {
                        maxBuffer: 50 * 1024 * 1024,
                        timeout: 300000
                    });
                }
                this.emitProgress('download', 25, 'Repository aktualisiert.');
            } else {
                this.emitProgress('download', 5, 'Klone ExploitDB Repository (kann mehrere Minuten dauern)...');
                // Shallow clone to save space and time - only get latest state
                execSync(`git clone --depth 1 "${EXPLOITDB_REPO}" "${EXPLOITDB_DIR}" 2>&1`, {
                    maxBuffer: 50 * 1024 * 1024,
                    timeout: 600000 // 10 minutes
                });
                this.emitProgress('download', 30, 'Repository geklont.');
            }

            // Step 2: Parse files_exploits.csv
            const csvPath = path.join(EXPLOITDB_DIR, 'files_exploits.csv');
            if (!fs.existsSync(csvPath)) {
                throw new Error('files_exploits.csv nicht gefunden im Repository');
            }

            this.emitProgress('parse', 35, 'Parse files_exploits.csv...');
            const exploits = await this.parseExploitsCsv(csvPath);
            logger.info(`Parsed ${exploits.length} exploits from files_exploits.csv`);

            // Step 3: Also parse files_shellcodes.csv if available
            let shellcodes = [];
            const shellcodesPath = path.join(EXPLOITDB_DIR, 'files_shellcodes.csv');
            if (fs.existsSync(shellcodesPath)) {
                this.emitProgress('parse', 45, 'Parse files_shellcodes.csv...');
                shellcodes = await this.parseShellcodesCsv(shellcodesPath);
                logger.info(`Parsed ${shellcodes.length} shellcodes`);
            }

            // Step 4: Import into database
            this.emitProgress('import', 50, `Importiere ${exploits.length} Exploits in Datenbank...`);

            let added = 0, updated = 0, errors = 0;

            // Clear old exploitdb-sourced entries
            const deleteOld = db.prepare("DELETE FROM exploits WHERE source = 'exploit-db'");

            const insertStmt = db.prepare(`
                INSERT INTO exploits (exploit_db_id, cve_id, title, description, platform, exploit_type, 
                    service_name, service_version_min, service_version_max, port, severity, cvss_score, 
                    reliability, source, source_url, exploit_code, verified)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'exploit-db', ?, ?, ?)
            `);

            const BATCH_SIZE = 2000;

            const importBatch = db.transaction((items, isFirst) => {
                if (isFirst) {
                    const deleted = deleteOld.run();
                    logger.info(`Deleted ${deleted.changes} old exploit-db entries`);
                }

                for (const e of items) {
                    try {
                        insertStmt.run(
                            e.edbId, e.cveId, e.title, e.description,
                            e.platform, e.type, e.serviceName, null, null,
                            e.port, e.severity, e.cvssScore,
                            e.verified ? 'verified' : 'unknown',
                            e.sourceUrl, e.codePath, e.verified ? 1 : 0
                        );
                        added++;
                    } catch (err) {
                        errors++;
                    }
                }
            });

            // Process in batches
            let isFirst = true;
            for (let i = 0; i < exploits.length; i += BATCH_SIZE) {
                const batch = exploits.slice(i, i + BATCH_SIZE);
                importBatch(batch, isFirst);
                isFirst = false;
                const pct = 50 + Math.round((i / exploits.length) * 40);
                this.emitProgress('import', pct, `Importiert: ${added} / ${exploits.length} (${errors} Fehler)`);
            }

            // Import shellcodes as a special type
            if (shellcodes.length > 0) {
                this.emitProgress('import', 92, `Importiere ${shellcodes.length} Shellcodes...`);
                const shellBatch = db.transaction((items) => {
                    for (const s of items) {
                        try {
                            insertStmt.run(
                                s.edbId, null, s.title, s.description,
                                s.platform, 'shellcode', null, null, null,
                                null, 'medium', null,
                                'unknown', s.sourceUrl, s.codePath, 0
                            );
                            added++;
                        } catch (err) {
                            errors++;
                        }
                    }
                });
                shellBatch(shellcodes);
            }

            const countAfter = db.prepare('SELECT COUNT(*) as c FROM exploits').get().c;

            // Calculate repo size
            let repoSize = 'unbekannt';
            try {
                const sizeOutput = execSync(`du -sh "${EXPLOITDB_DIR}" 2>/dev/null`).toString().trim();
                repoSize = sizeOutput.split('\t')[0];
            } catch (e) {}

            db.prepare(`
                UPDATE db_update_log SET entries_added = ?, entries_updated = ?, entries_after = ?,
                status = 'completed', completed_at = CURRENT_TIMESTAMP WHERE id = ?
            `).run(added, updated, countAfter, logId);

            this.emitProgress('done', 100, `Fertig! ${added} Exploits importiert. Gesamt: ${countAfter}. Repo: ${repoSize}`);

            logger.info(`ExploitDB sync completed: ${added} added, ${errors} errors (${countBefore} â†’ ${countAfter})`);

            return {
                success: true,
                message: `Exploit-Datenbank aktualisiert: ${added} Exploits aus ExploitDB importiert`,
                stats: {
                    before: countBefore, added, updated, errors, after: countAfter,
                    repoSize, shellcodes: shellcodes.length
                }
            };

        } catch (err) {
            db.prepare(`
                UPDATE db_update_log SET status = 'error', error_message = ?, completed_at = CURRENT_TIMESTAMP WHERE id = ?
            `).run(err.message, logId);
            this.emitProgress('error', 0, `Fehler: ${err.message}`);
            logger.error('ExploitDB sync error:', err);
            throw err;
        }
    }

    /**
     * Parse files_exploits.csv
     * CSV columns: id, file, description, date_published, author, platform, type, port, codes
     */
    static async parseExploitsCsv(csvPath) {
        const results = [];
        const readline = require('readline');
        const fileStream = fs.createReadStream(csvPath);
        const rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity });

        let processedLines = 0;
        for await (const line of rl) {
            processedLines++;
            if (processedLines === 1) continue; // Skip header
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            try {
                const fields = this.parseCSVLine(trimmedLine);
                if (fields.length < 9) continue;

                const edbId = fields[0]?.trim();
                const filePath = fields[1]?.trim();
                const title = fields[2]?.trim();
                const datePublished = fields[3]?.trim();
                const author = fields[4]?.trim();
                const platform = fields[5]?.trim();
                const type = fields[6]?.trim();
                const port = fields[7]?.trim();
                const codes = fields[8]?.trim(); // CVE codes, semicolon separated

                if (!edbId || !title) continue;

                // Parse CVE IDs from codes field
                let cveId = null;
                if (codes) {
                    const cveMatch = codes.match(/CVE-\d{4}-\d+/);
                    if (cveMatch) cveId = cveMatch[0];
                }

                // Determine severity based on type
                let severity = 'medium';
                const typeLower = (type || '').toLowerCase();
                if (typeLower === 'remote') severity = 'high';
                else if (typeLower === 'webapps') severity = 'high';
                else if (typeLower === 'local') severity = 'medium';
                else if (typeLower === 'dos') severity = 'medium';

                // Determine service name from title
                const serviceName = this.extractServiceFromTitle(title);

                // Parse port
                let portNum = null;
                if (port && port !== '' && port !== '0') {
                    portNum = parseInt(port, 10);
                    if (isNaN(portNum) || portNum <= 0 || portNum > 65535) portNum = null;
                }

                // Determine if verified (ExploitDB marks verified exploits)
                const verified = filePath && filePath.includes('/');

                // Build code path (relative to exploitdb dir)
                const codePath = filePath ? path.join(EXPLOITDB_DIR, filePath) : null;

                results.push({
                    edbId: `EDB-${edbId}`,
                    cveId,
                    title: title.substring(0, 500),
                    description: `${title} (Author: ${author || 'unknown'}, Published: ${datePublished || 'unknown'})`,
                    platform: this.normalizePlatform(platform),
                    type: this.normalizeType(type),
                    serviceName,
                    port: portNum,
                    severity,
                    cvssScore: null,
                    verified: !!verified,
                    sourceUrl: `https://www.exploit-db.com/exploits/${edbId}`,
                    codePath: codePath && fs.existsSync(codePath) ? codePath : null,
                    datePublished,
                    author
                });
            } catch (e) {
                // Skip malformed lines
                continue;
            }
        }

        return results;
    }

    /**
     * Parse files_shellcodes.csv
     */
    static async parseShellcodesCsv(csvPath) {
        const results = [];
        const readline = require('readline');
        const fileStream = fs.createReadStream(csvPath);
        const rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity });

        let processedLines = 0;
        for await (const line of rl) {
            processedLines++;
            if (processedLines === 1) continue; // Skip header
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            try {
                const fields = this.parseCSVLine(trimmedLine);
                if (fields.length < 5) continue;

                const edbId = fields[0]?.trim();
                const filePath = fields[1]?.trim();
                const title = fields[2]?.trim();
                const datePublished = fields[3]?.trim();
                const platform = fields[5]?.trim();

                if (!edbId || !title) continue;

                const codePath = filePath ? path.join(EXPLOITDB_DIR, filePath) : null;

                results.push({
                    edbId: `SHELLCODE-${edbId}`,
                    title: title.substring(0, 500),
                    description: `Shellcode: ${title}`,
                    platform: this.normalizePlatform(platform),
                    sourceUrl: `https://www.exploit-db.com/shellcodes/${edbId}`,
                    codePath: codePath && fs.existsSync(codePath) ? codePath : null
                });
            } catch (e) {
                continue;
            }
        }

        return results;
    }

    /**
     * Parse a CSV line handling quoted fields
     */
    static parseCSVLine(line) {
        const fields = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const ch = line[i];
            if (ch === '"') {
                if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (ch === ',' && !inQuotes) {
                fields.push(current);
                current = '';
            } else {
                current += ch;
            }
        }
        fields.push(current);
        return fields;
    }

    /**
     * Extract service name from exploit title
     */
    static extractServiceFromTitle(title) {
        const t = title.toLowerCase();
        const serviceMap = {
            'openssh': 'OpenSSH', 'ssh': 'SSH', 'apache': 'Apache httpd',
            'nginx': 'nginx', 'iis': 'IIS', 'tomcat': 'Apache Tomcat',
            'mysql': 'MySQL', 'mariadb': 'MariaDB', 'postgresql': 'PostgreSQL',
            'postgres': 'PostgreSQL', 'mongodb': 'MongoDB', 'redis': 'Redis',
            'ftp': 'FTP', 'vsftpd': 'vsftpd', 'proftpd': 'ProFTPD',
            'samba': 'Samba SMB', 'smb': 'SMB', 'rdp': 'RDP',
            'vnc': 'VNC', 'telnet': 'Telnet', 'smtp': 'SMTP',
            'postfix': 'Postfix', 'exim': 'Exim', 'sendmail': 'Sendmail',
            'exchange': 'Exchange', 'wordpress': 'WordPress', 'drupal': 'Drupal',
            'joomla': 'Joomla', 'jenkins': 'Jenkins', 'docker': 'Docker',
            'kubernetes': 'Kubernetes', 'elasticsearch': 'Elasticsearch',
            'kibana': 'Kibana', 'grafana': 'Grafana', 'oracle': 'Oracle DB',
            'mssql': 'Microsoft SQL Server', 'sql server': 'Microsoft SQL Server',
            'phpmyadmin': 'phpMyAdmin', 'webmin': 'Webmin',
            'bind': 'BIND', 'dns': 'DNS', 'openssl': 'OpenSSL',
            'php': 'PHP', 'python': 'Python', 'node': 'Node.js',
            'java': 'Java', 'spring': 'Spring Framework',
            'log4j': 'Log4j', 'struts': 'Apache Struts',
            'confluence': 'Confluence', 'jira': 'Jira',
            'gitlab': 'GitLab', 'github': 'GitHub',
            'windows': null, 'linux': null, 'macos': null
        };

        for (const [key, value] of Object.entries(serviceMap)) {
            if (t.includes(key) && value) return value;
        }
        return null;
    }

    /**
     * Normalize platform names
     */
    static normalizePlatform(platform) {
        if (!platform) return 'Multi';
        const p = platform.toLowerCase().trim();
        if (p.includes('linux')) return 'Linux';
        if (p.includes('windows')) return 'Windows';
        if (p.includes('osx') || p.includes('macos') || p.includes('mac_os')) return 'macOS';
        if (p.includes('freebsd') || p.includes('openbsd') || p.includes('netbsd')) return 'BSD';
        if (p.includes('android')) return 'Android';
        if (p.includes('ios')) return 'iOS';
        if (p.includes('multiple') || p.includes('multi')) return 'Multi';
        if (p.includes('hardware')) return 'Hardware';
        if (p.includes('php')) return 'PHP';
        if (p.includes('python')) return 'Python';
        if (p.includes('java')) return 'Java';
        if (p.includes('asp') || p.includes('.net')) return 'Windows';
        if (p.includes('cgi')) return 'CGI';
        if (p.includes('cfm')) return 'ColdFusion';
        if (p.includes('jsp')) return 'Java';
        if (p.includes('xml')) return 'Multi';
        if (p.includes('json')) return 'Multi';
        // Return capitalized original if no match
        return platform.charAt(0).toUpperCase() + platform.slice(1).toLowerCase();
    }

    /**
     * Normalize exploit type
     */
    static normalizeType(type) {
        if (!type) return 'remote';
        const t = type.toLowerCase().trim();
        if (t === 'remote') return 'remote';
        if (t === 'local') return 'local';
        if (t === 'webapps') return 'webapps';
        if (t === 'dos') return 'dos';
        if (t === 'shellcode') return 'shellcode';
        if (t === 'papers') return 'papers';
        return t;
    }

    /**
     * Get exploit code content by exploit ID
     */
    static getExploitCode(exploitId) {
        const db = getDatabase();
        const exploit = db.prepare('SELECT exploit_code, exploit_db_id, title FROM exploits WHERE id = ?').get(exploitId);
        if (!exploit) return null;

        // If we have a stored code path, read it
        if (exploit.exploit_code && fs.existsSync(exploit.exploit_code)) {
            try {
                const code = fs.readFileSync(exploit.exploit_code, 'utf8');
                const ext = path.extname(exploit.exploit_code).toLowerCase();
                let language = 'text';
                if (['.py', '.python'].includes(ext)) language = 'python';
                else if (['.rb'].includes(ext)) language = 'ruby';
                else if (['.pl'].includes(ext)) language = 'perl';
                else if (['.c', '.cpp', '.h'].includes(ext)) language = 'c';
                else if (['.java'].includes(ext)) language = 'java';
                else if (['.sh', '.bash'].includes(ext)) language = 'bash';
                else if (['.php'].includes(ext)) language = 'php';
                else if (['.js'].includes(ext)) language = 'javascript';
                else if (['.html', '.htm'].includes(ext)) language = 'html';
                else if (['.txt'].includes(ext)) language = 'text';

                return {
                    code: code.substring(0, 100000), // Limit to 100KB
                    language,
                    filePath: exploit.exploit_code,
                    fileName: path.basename(exploit.exploit_code),
                    size: fs.statSync(exploit.exploit_code).size
                };
            } catch (e) {
                logger.error(`Error reading exploit code for ${exploitId}:`, e);
            }
        }

        return null;
    }

    /**
     * List available exploit files in the repo
     */
    static getRepoStats() {
        if (!this.isRepoCloned()) {
            return { cloned: false, size: null, exploitCount: 0, shellcodeCount: 0 };
        }

        try {
            const sizeOutput = execSync(`du -sh "${EXPLOITDB_DIR}" 2>/dev/null`).toString().trim();
            const size = sizeOutput.split('\t')[0];

            let exploitCount = 0;
            let shellcodeCount = 0;

            const exploitsDir = path.join(EXPLOITDB_DIR, 'exploits');
            const shellcodesDir = path.join(EXPLOITDB_DIR, 'shellcodes');

            if (fs.existsSync(exploitsDir)) {
                exploitCount = parseInt(execSync(`find "${exploitsDir}" -type f | wc -l`).toString().trim(), 10);
            }
            if (fs.existsSync(shellcodesDir)) {
                shellcodeCount = parseInt(execSync(`find "${shellcodesDir}" -type f | wc -l`).toString().trim(), 10);
            }

            return { cloned: true, size, exploitCount, shellcodeCount };
        } catch (e) {
            return { cloned: true, size: 'unknown', exploitCount: 0, shellcodeCount: 0 };
        }
    }
}

module.exports = ExploitDbSyncService;