const { getDatabase } = require('../config/database');
const logger = require('./logger');
const fs = require('fs');
const path = require('path');
const { exec, execSync } = require('child_process');
const util = require('util');
const execAsync = util.promisify(exec);

const DATA_DIR = path.join(__dirname, '..', 'data');
const EXPLOITDB_DIR = path.join(DATA_DIR, 'exploitdb');

class ExploitDbSyncService {

    /**
     * Check if the exploitdb repo already exists locally
     */
    static isRepoCloned() {
        return fs.existsSync(path.join(EXPLOITDB_DIR, '.git'));
    }

    /**
     * Get exploit code content by exploit ID
     */
    static getExploitCode(exploitId) {
        const db = getDatabase();
        const exploit = db.prepare('SELECT exploit_code, exploit_db_id, title FROM exploits WHERE id = ?').get(exploitId);
        if (!exploit) return null;

        // If we have a stored code path, read it
        if (exploit.exploit_code && fs.existsSync(exploit.exploit_code)) {
            try {
                const code = fs.readFileSync(exploit.exploit_code, 'utf8');
                const ext = path.extname(exploit.exploit_code).toLowerCase();
                let language = 'text';
                if (['.py', '.python'].includes(ext)) language = 'python';
                else if (['.rb'].includes(ext)) language = 'ruby';
                else if (['.pl'].includes(ext)) language = 'perl';
                else if (['.c', '.cpp', '.h'].includes(ext)) language = 'c';
                else if (['.java'].includes(ext)) language = 'java';
                else if (['.sh', '.bash'].includes(ext)) language = 'bash';
                else if (['.php'].includes(ext)) language = 'php';
                else if (['.js'].includes(ext)) language = 'javascript';
                else if (['.html', '.htm'].includes(ext)) language = 'html';
                else if (['.txt'].includes(ext)) language = 'text';

                return {
                    code: code.substring(0, 100000), // Limit to 100KB
                    language,
                    filePath: exploit.exploit_code,
                    fileName: path.basename(exploit.exploit_code),
                    size: fs.statSync(exploit.exploit_code).size
                };
            } catch (e) {
                logger.error(`Error reading exploit code for ${exploitId}:`, e);
            }
        }

        return null;
    }

    /**
     * List available exploit files in the repo
     */
    static async getRepoStats() {
        if (!this.isRepoCloned()) {
            return { cloned: false, size: null, exploitCount: 0, shellcodeCount: 0 };
        }

        try {
            const exploitsDir = path.join(EXPLOITDB_DIR, 'exploits');
            const shellcodesDir = path.join(EXPLOITDB_DIR, 'shellcodes');

            const promises = [
                execAsync(`du -sh "${EXPLOITDB_DIR}" 2>/dev/null`)
            ];

            if (fs.existsSync(exploitsDir)) {
                promises.push(execAsync(`find "${exploitsDir}" -type f | wc -l`));
            } else {
                promises.push(Promise.resolve({ stdout: '0' }));
            }

            if (fs.existsSync(shellcodesDir)) {
                promises.push(execAsync(`find "${shellcodesDir}" -type f | wc -l`));
            } else {
                promises.push(Promise.resolve({ stdout: '0' }));
            }

            const [sizeRes, exploitRes, shellcodeRes] = await Promise.all(promises);

            const size = sizeRes.stdout.trim().split('\t')[0];
            const exploitCount = parseInt(exploitRes.stdout.trim(), 10);
            const shellcodeCount = parseInt(shellcodeRes.stdout.trim(), 10);

            return { cloned: true, size, exploitCount, shellcodeCount };
        } catch (e) {
            return { cloned: true, size: 'unknown', exploitCount: 0, shellcodeCount: 0 };
        }
    }
}

module.exports = ExploitDbSyncService;
